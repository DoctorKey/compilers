!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A0	mips32.h	10;"	d
A1	mips32.h	11;"	d
A2	mips32.h	12;"	d
A3	mips32.h	13;"	d
ADD_IR	IR.h	/^		ASSIGN_IR, ADD_IR, SUB_IR, MUL_IR, DIV_IR, $/;"	e	enum:__anon10
ARG_IR	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	e	enum:__anon10
ARRAY	symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE} kind;$/;"	e	enum:Type_::__anon1
ASSIGN_IR	IR.h	/^		ASSIGN_IR, ADD_IR, SUB_IR, MUL_IR, DIV_IR, $/;"	e	enum:__anon10
AT	mips32.h	5;"	d
A_ADD	asm.h	/^	A_ADDI, A_ADD, A_SUB, A_MUL, A_DIV,$/;"	e	enum:__anon17
A_ADDI	asm.h	/^	A_ADDI, A_ADD, A_SUB, A_MUL, A_DIV,$/;"	e	enum:__anon17
A_BEQ	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_BGE	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_BGT	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_BLE	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_BLT	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_BNE	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	e	enum:__anon17
A_DIV	asm.h	/^	A_ADDI, A_ADD, A_SUB, A_MUL, A_DIV,$/;"	e	enum:__anon17
A_J	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
A_JAL	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
A_JR	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
A_LABEL	asm.h	/^	A_LABEL, A_LI, A_MOVE,$/;"	e	enum:__anon17
A_LI	asm.h	/^	A_LABEL, A_LI, A_MOVE,$/;"	e	enum:__anon17
A_LW	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
A_MFLO	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
A_MOVE	asm.h	/^	A_LABEL, A_LI, A_MOVE,$/;"	e	enum:__anon17
A_MUL	asm.h	/^	A_ADDI, A_ADD, A_SUB, A_MUL, A_DIV,$/;"	e	enum:__anon17
A_SUB	asm.h	/^	A_ADDI, A_ADD, A_SUB, A_MUL, A_DIV,$/;"	e	enum:__anon17
A_SW	asm.h	/^	A_MFLO, A_LW, A_SW, A_J, A_JAL, A_JR,$/;"	e	enum:__anon17
ArgIR	IR.c	/^InterCode ArgIR(Operand x) {$/;"	f
Args	name.h	/^	Exp, Args$/;"	e	enum:__anon16
Args	syntax.y	/^Args : Exp COMMA Args	$/;"	l
ArgsAnalyze	semantic.c	/^void ArgsAnalyze(TreeNode parent, int num) {$/;"	f
ArgsTrans	translateIR.c	/^void ArgsTrans(TreeNode parent, int num) {$/;"	f
AsmCode	asm.h	/^typedef struct AsmCode_* AsmCode;$/;"	t	typeref:struct:AsmCode_
AsmCodeKind	asm.h	/^	A_BEQ, A_BNE, A_BGT, A_BLT, A_BGE, A_BLE }AsmCodeKind;$/;"	t	typeref:enum:__anon17
AsmCode_	asm.h	/^struct AsmCode_ {$/;"	s
AsmCodes	asm.h	/^typedef struct AsmCodes_* AsmCodes;$/;"	t	typeref:struct:AsmCodes_
AsmCodes_	asm.h	/^struct AsmCodes_ {$/;"	s
AsmHead	asm.c	/^AsmCodes AsmHead = NULL;$/;"	v
AsmTail	asm.c	/^AsmCodes AsmTail = NULL;$/;"	v
Assign2IR	IR.c	/^InterCode Assign2IR(Operand x, Operand y) {$/;"	f
Assign3AddrIR	IR.c	/^InterCode Assign3AddrIR(Operand x, Operand y, int kind, Operand z) {$/;"	f
Assign3IR	IR.c	/^InterCode Assign3IR(Operand x, Operand y, int kind, Operand z) {$/;"	f
BASIC	symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE} kind;$/;"	e	enum:Type_::__anon1
BISON	Makefile	/^BISON = bison$/;"	m
BeginToken	file.c	/^void BeginToken(char *t) {$/;"	f
Buffer	file.h	/^struct Buffer {$/;"	s
CALL_IR	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	e	enum:__anon10
CC	Makefile	/^CC = gcc$/;"	m
CFILES	Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Makefile	/^CFLAGS =-g -std=c99$/;"	m
CHILD_NUM	tree.h	8;"	d
CONSTANT_OP	IR.h	/^typedef enum {TEMP_OP, VARIABLE_OP, CONSTANT_OP, FUNC_OP,$/;"	e	enum:__anon7
CallIR	IR.c	/^InterCode CallIR(Operand x, char *funcname) {$/;"	f
CompSt	name.h	/^	CompSt, StmtList, Stmt, M, N,  $/;"	e	enum:__anon16
CompSt	syntax.y	/^CompSt : LC DefList StmtList RC $/;"	l
CompStAnalyze	semantic.c	/^void CompStAnalyze(TreeNode parent, int num) {$/;"	f
CompStTrans	translateIR.c	/^void CompStTrans(TreeNode parent, int num) {$/;"	f
DEC_IR	IR.h	/^		GOTO_IR, IF_IR, RETURN_IR, DEC_IR, $/;"	e	enum:__anon10
DIV_IR	IR.h	/^		ASSIGN_IR, ADD_IR, SUB_IR, MUL_IR, DIV_IR, $/;"	e	enum:__anon10
Dec	name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon16
Dec	syntax.y	/^Dec : VarDec	$/;"	l
DecAnalyze	semantic.c	/^void DecAnalyze(TreeNode parent, int num) {$/;"	f
DecFuncList	semantichelp.c	/^struct FuncList *DecFuncList = NULL;$/;"	v	typeref:struct:FuncList
DecIR	IR.c	/^InterCode DecIR(Operand x, int size) {$/;"	f
DecList	name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon16
DecList	syntax.y	/^DecList : Dec	$/;"	l
DecListAnalyze	semantic.c	/^void DecListAnalyze(TreeNode parent, int num) {$/;"	f
DecListTrans	translateIR.c	/^void DecListTrans(TreeNode parent, int num) {$/;"	f
DecTrans	translateIR.c	/^void DecTrans(TreeNode parent, int num) {$/;"	f
Def	name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon16
Def	syntax.y	/^Def : Specifier DecList SEMI $/;"	l
DefAnalyze	semantic.c	/^void DefAnalyze(TreeNode parent, int num) {$/;"	f
DefList	name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon16
DefList	syntax.y	/^DefList :	$/;"	l
DefListAnalyze	semantic.c	/^void DefListAnalyze(TreeNode parent, int num) {$/;"	f
DefListTrans	translateIR.c	/^void DefListTrans(TreeNode parent, int num) {$/;"	f
DefTrans	translateIR.c	/^void DefTrans(TreeNode parent, int num) {$/;"	f
DumpRow	file.c	/^void DumpRow(void) {$/;"	f
ErrorInfo	error.h	/^typedef struct ErrorInfo_* ErrorInfo;$/;"	t	typeref:struct:ErrorInfo_
ErrorInfoStack	error.h	/^struct ErrorInfoStack {$/;"	s
ErrorInfo_	error.h	/^struct ErrorInfo_ {$/;"	s
ErrorLineNum	error.h	/^	int ErrorLineNum;$/;"	m	struct:ErrorInfo_
ErrorLineStr	error.h	/^	char *ErrorLineStr;$/;"	m	struct:ErrorInfo_
ErrorStrType	error.h	/^	int ErrorStrType;$/;"	m	struct:ErrorInfo_
ErrorTypeNum	error.h	/^	int ErrorTypeNum;$/;"	m	struct:ErrorInfo_
Exp	name.h	/^	Exp, Args$/;"	e	enum:__anon16
Exp	syntax.y	/^Exp : Exp ASSIGNOP Exp $/;"	l
ExpAnalyze	semantic.c	/^void ExpAnalyze(TreeNode parent, int num) {$/;"	f
ExpTrans	translateIR.c	/^void ExpTrans(TreeNode parent, int num) {$/;"	f
ExtDecList	name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon16
ExtDecList	syntax.y	/^ExtDecList : VarDec	$/;"	l
ExtDecListAnalyze	semantic.c	/^void ExtDecListAnalyze(TreeNode parent, int num) {$/;"	f
ExtDecListTrans	translateIR.c	/^void ExtDecListTrans(TreeNode parent, int num) {$/;"	f
ExtDef	name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon16
ExtDef	syntax.y	/^ExtDef : Specifier ExtDecList SEMI $/;"	l
ExtDefAnalyze	semantic.c	/^void ExtDefAnalyze(TreeNode parent, int num) {$/;"	f
ExtDefList	name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon16
ExtDefList	syntax.y	/^ExtDefList : 	$/;"	l
ExtDefListAnalyze	semantic.c	/^void ExtDefListAnalyze(TreeNode parent, int num) {$/;"	f
ExtDefListTrans	translateIR.c	/^void ExtDefListTrans(TreeNode parent, int num) {$/;"	f
ExtDefTrans	translateIR.c	/^void ExtDefTrans(TreeNode parent, int num) {$/;"	f
FALL_OP	IR.h	/^		RELOP_OP, LABEL_OP, SIZE_OP, FALL_OP} OP_KIND;$/;"	e	enum:__anon7
FLEX	Makefile	/^FLEX = flex$/;"	m
FLOAT	tree.h	/^	float FLOAT;$/;"	m	union:value
FP	mips32.h	41;"	d
FUNCTION_IR	IR.h	/^typedef enum { LABEL_IR, FUNCTION_IR, $/;"	e	enum:__anon10
FUNC_OP	IR.h	/^typedef enum {TEMP_OP, VARIABLE_OP, CONSTANT_OP, FUNC_OP,$/;"	e	enum:__anon7
FieldList	symtable.h	/^typedef struct FieldList_* FieldList;$/;"	t	typeref:struct:FieldList_
FieldList_	symtable.h	/^struct FieldList_ {$/;"	s
Float	IR.h	/^	enum {String, Int, Float} type;$/;"	e	enum:Operand_::__anon8
FreeErrorInfo	error.c	/^void FreeErrorInfo(ErrorInfo errorInfo) {$/;"	f
FunDec	name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon16
FunDec	syntax.y	/^FunDec : ID LP VarList RP $/;"	l
FunDecAnalyze	semantic.c	/^void FunDecAnalyze(TreeNode parent, int num) {$/;"	f
FunDecTrans	translateIR.c	/^void FunDecTrans(TreeNode parent, int num) {$/;"	f
Func	symtable.h	/^enum {Var, Func, Struct};$/;"	e	enum:__anon5
Func	symtable.h	/^struct Func {$/;"	s
FuncList	semantichelp.h	/^struct FuncList {$/;"	s
Funcsymbol	semantic.c	/^Symbol Funcsymbol = NULL;$/;"	v
FunctionIR	IR.c	/^InterCode FunctionIR(char *funcname) {$/;"	f
GFuncReturn	semantic.c	/^Type GFuncReturn = NULL;$/;"	v
GOTO_IR	IR.h	/^		GOTO_IR, IF_IR, RETURN_IR, DEC_IR, $/;"	e	enum:__anon10
GP	mips32.h	39;"	d
GerrorInfo	error.c	/^ErrorInfo GerrorInfo = NULL;$/;"	v
GetErrorInfoByNum	error.c	/^ErrorInfo GetErrorInfoByNum(struct ErrorInfoStack *head, int num) {$/;"	f
GetNextChar	file.c	/^int GetNextChar(char *b, int maxBuffer) {$/;"	f
GetTotalErrorInfo	error.c	/^int GetTotalErrorInfo() {$/;"	f
GotoIR	IR.c	/^InterCode GotoIR(Operand n) {$/;"	f
Gspecifier	semantic.c	/^Type Gspecifier = NULL;$/;"	v
HASHSIZE	symtable.h	18;"	d
HashNode	symtable.h	/^struct HashNode {$/;"	s
HashTableInfo	symtable.h	/^struct HashTableInfo {$/;"	s
IF_IR	IR.h	/^		GOTO_IR, IF_IR, RETURN_IR, DEC_IR, $/;"	e	enum:__anon10
INT	tree.h	/^	int INT;$/;"	m	union:value
IR_init	IR.c	/^void IR_init() {$/;"	f
IRhead	IR.c	/^InterCodes IRhead = NULL;$/;"	v
IRinfo	IR.h	/^typedef struct IRinfo_* IRinfo;$/;"	t	typeref:struct:IRinfo_
IRinfo_	IR.h	/^struct IRinfo_ {$/;"	s
IRtail	IR.c	/^InterCodes IRtail = NULL;$/;"	v
IdErrorInfoStackHead	error.c	/^struct ErrorInfoStack *IdErrorInfoStackHead = NULL;$/;"	v	typeref:struct:ErrorInfoStack
IfIR	IR.c	/^InterCode IfIR(Operand x, char *relop, Operand y, Operand z) {$/;"	f
Int	IR.h	/^	enum {String, Int, Float} type;$/;"	e	enum:Operand_::__anon8
InterCode	IR.h	/^typedef struct InterCode_* InterCode;$/;"	t	typeref:struct:InterCode_
InterCodeKind	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	t	typeref:enum:__anon10
InterCode_	IR.h	/^struct InterCode_ {$/;"	s
InterCodes	IR.h	/^typedef struct InterCodes_* InterCodes;$/;"	t	typeref:struct:InterCodes_
InterCodes_	IR.h	/^struct InterCodes_ {$/;"	s
K0	mips32.h	36;"	d
K1	mips32.h	37;"	d
LABEL_IR	IR.h	/^typedef enum { LABEL_IR, FUNCTION_IR, $/;"	e	enum:__anon10
LABEL_NUM	IRopt.c	5;"	d	file:
LABEL_OP	IR.h	/^		RELOP_OP, LABEL_OP, SIZE_OP, FALL_OP} OP_KIND;$/;"	e	enum:__anon7
LAB_1	main.h	11;"	d
LAB_2	main.h	12;"	d
LAB_3	main.h	13;"	d
LAB_4	main.h	14;"	d
LFC	Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
LabelIR	IR.c	/^InterCode LabelIR(int n) {$/;"	f
M	name.h	/^	CompSt, StmtList, Stmt, M, N,  $/;"	e	enum:__anon16
MTrans	translateIR.c	/^void MTrans(TreeNode parent, int num) {$/;"	f
MUL_IR	IR.h	/^		ASSIGN_IR, ADD_IR, SUB_IR, MUL_IR, DIV_IR, $/;"	e	enum:__anon10
Mpop	IR.c	/^Operand Mpop() {$/;"	f
Mpush	IR.c	/^void Mpush(Operand M) {$/;"	f
Mstack	IR.c	/^Operandlist Mstack = NULL;$/;"	v
N	name.h	/^	CompSt, StmtList, Stmt, M, N,  $/;"	e	enum:__anon16
NTrans	translateIR.c	/^void NTrans(TreeNode parent, int num) {$/;"	f
Nlist_	IR.c	/^struct Nlist_ {$/;"	s	file:
Npop	IR.c	/^Operandlist Npop() {$/;"	f
Npush	IR.c	/^void Npush(Operandlist N) {$/;"	f
Nstack	IR.c	/^struct Nlist_ *Nstack = NULL;$/;"	v	typeref:struct:Nlist_
NumErrorInfoStackHead	error.c	/^struct ErrorInfoStack *NumErrorInfoStackHead = NULL;$/;"	v	typeref:struct:ErrorInfoStack
OBJS	Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
OP_KIND	IR.h	/^		RELOP_OP, LABEL_OP, SIZE_OP, FALL_OP} OP_KIND;$/;"	t	typeref:enum:__anon7
Opbackpatch	IR.c	/^void Opbackpatch(Operandlist oplist, Operand label) {$/;"	f
Operand	IR.h	/^typedef struct Operand_* Operand;$/;"	t	typeref:struct:Operand_
Operand_	IR.h	/^struct Operand_ {$/;"	s
Operandlist	IR.h	/^typedef struct Operandlist_* Operandlist;$/;"	t	typeref:struct:Operandlist_
Operandlist_	IR.h	/^struct Operandlist_ {$/;"	s
Opmakelist	IR.c	/^Operandlist Opmakelist(Operand op) {$/;"	f
Opmerge	IR.c	/^Operandlist Opmerge(Operandlist oplist1, Operandlist oplist2) {$/;"	f
OptTag	name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon16
OptTag	syntax.y	/^OptTag : 	$/;"	l
OptTagAnalyze	semantic.c	/^void OptTagAnalyze(TreeNode parent, int num) {$/;"	f
OptTagTrans	translateIR.c	/^void OptTagTrans(TreeNode parent, int num) {$/;"	f
OptoAddrstring	IR.c	/^char *OptoAddrstring(Operand op) {$/;"	f
Optostring	IR.c	/^char *Optostring(Operand op) {$/;"	f
Opvaluetostring	IR.c	/^char *Opvaluetostring(Operand op) {$/;"	f
PARAM_IR	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	e	enum:__anon10
ParamDec	name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon16
ParamDec	syntax.y	/^ParamDec : Specifier VarDec	$/;"	l
ParamDecAnalyze	semantic.c	/^void ParamDecAnalyze(TreeNode parent, int num) {$/;"	f
ParamDecTrans	translateIR.c	/^void ParamDecTrans(TreeNode parent, int num) {$/;"	f
ParamIR	IR.c	/^InterCode ParamIR(Operand x) {$/;"	f
PrintError	error.c	/^void PrintError(char type, char *errorstring, ...) {$/;"	f
Program	name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon16
Program	syntax.y	/^Program : ExtDefList	$/;"	l
ProgramAnalyze	semantic.c	/^void ProgramAnalyze(TreeNode parent, int num) {$/;"	f
ProgramTrans	translateIR.c	/^void ProgramTrans(TreeNode parent, int num) {$/;"	f
RA	mips32.h	42;"	d
READ_IR	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	e	enum:__anon10
RELOP_OP	IR.h	/^		RELOP_OP, LABEL_OP, SIZE_OP, FALL_OP} OP_KIND;$/;"	e	enum:__anon7
RETURN_IR	IR.h	/^		GOTO_IR, IF_IR, RETURN_IR, DEC_IR, $/;"	e	enum:__anon10
ReadIR	IR.c	/^InterCode ReadIR(Operand x) {$/;"	f
Return	symtable.h	/^	Type Return;$/;"	m	struct:Func
ReturnIR	IR.c	/^InterCode ReturnIR(Operand x) {$/;"	f
S0	mips32.h	24;"	d
S1	mips32.h	25;"	d
S2	mips32.h	26;"	d
S3	mips32.h	27;"	d
S4	mips32.h	28;"	d
S5	mips32.h	29;"	d
S6	mips32.h	30;"	d
S7	mips32.h	31;"	d
SIZE_OP	IR.h	/^		RELOP_OP, LABEL_OP, SIZE_OP, FALL_OP} OP_KIND;$/;"	e	enum:__anon7
SP	mips32.h	40;"	d
STRUCTURE	symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE} kind;$/;"	e	enum:Type_::__anon1
SUB_IR	IR.h	/^		ASSIGN_IR, ADD_IR, SUB_IR, MUL_IR, DIV_IR, $/;"	e	enum:__anon10
SYMBOLMAX	symtable.h	17;"	d
SemanticError	error.c	/^void SemanticError(ErrorInfo errorInfo) {$/;"	f
ShowErrorInfo	error.c	/^void ShowErrorInfo(ErrorInfo errorInfo) {$/;"	f
ShowErrorInfoStack	error.c	/^void ShowErrorInfoStack(struct ErrorInfoStack *head) {$/;"	f
Specifier	name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon16
Specifier	syntax.y	/^Specifier : TYPE $/;"	l
SpecifierAnalyze	semantic.c	/^void SpecifierAnalyze(TreeNode parent, int num) {$/;"	f
SpecifierTrans	translateIR.c	/^void SpecifierTrans(TreeNode parent, int num) {$/;"	f
Stmt	name.h	/^	CompSt, StmtList, Stmt, M, N,  $/;"	e	enum:__anon16
Stmt	syntax.y	/^Stmt : Exp SEMI	$/;"	l
StmtAnalyze	semantic.c	/^void StmtAnalyze(TreeNode parent, int num) {$/;"	f
StmtList	name.h	/^	CompSt, StmtList, Stmt, M, N,  $/;"	e	enum:__anon16
StmtList	syntax.y	/^StmtList : 	$/;"	l
StmtListAnalyze	semantic.c	/^void StmtListAnalyze(TreeNode parent, int num) {$/;"	f
StmtListTrans	translateIR.c	/^void StmtListTrans(TreeNode parent, int num) {$/;"	f
StmtTrans	translateIR.c	/^void StmtTrans(TreeNode parent, int num) {$/;"	f
String	IR.h	/^	enum {String, Int, Float} type;$/;"	e	enum:Operand_::__anon8
Struct	symtable.h	/^enum {Var, Func, Struct};$/;"	e	enum:__anon5
StructSpecifier	name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon16
StructSpecifier	syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC	$/;"	l
StructSpecifierAnalyze	semantic.c	/^void StructSpecifierAnalyze(TreeNode parent, int num) {$/;"	f
StructSpecifierTrans	translateIR.c	/^void StructSpecifierTrans(TreeNode parent, int num) {$/;"	f
SymNode	symtable.h	/^struct SymNode {$/;"	s
Symbol	symtable.h	/^typedef struct SymNode* Symbol;$/;"	t	typeref:struct:SymNode
T0	mips32.h	15;"	d
T1	mips32.h	16;"	d
T2	mips32.h	17;"	d
T3	mips32.h	18;"	d
T4	mips32.h	19;"	d
T5	mips32.h	20;"	d
T6	mips32.h	21;"	d
T7	mips32.h	22;"	d
T8	mips32.h	33;"	d
T9	mips32.h	34;"	d
TEMP_OP	IR.h	/^typedef enum {TEMP_OP, VARIABLE_OP, CONSTANT_OP, FUNC_OP,$/;"	e	enum:__anon7
Tag	name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon16
Tag	syntax.y	/^Tag : ID	$/;"	l
TagAnalyze	semantic.c	/^void TagAnalyze(TreeNode parent, int num) {$/;"	f
TagTrans	translateIR.c	/^void TagTrans(TreeNode parent, int num) {$/;"	f
TreeNode	tree.h	/^typedef struct node* TreeNode;$/;"	t	typeref:struct:node
Type	symtable.h	/^typedef struct Type_* Type;$/;"	t	typeref:struct:Type_
Type_	symtable.h	/^struct Type_ {$/;"	s
V0	mips32.h	7;"	d
V1	mips32.h	8;"	d
VARIABLE_OP	IR.h	/^typedef enum {TEMP_OP, VARIABLE_OP, CONSTANT_OP, FUNC_OP,$/;"	e	enum:__anon7
Var	symtable.h	/^enum {Var, Func, Struct};$/;"	e	enum:__anon5
Var	symtable.h	/^struct Var {$/;"	s
VarDec	name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon16
VarDec	syntax.y	/^VarDec : ID	$/;"	l
VarDecAnalyze	semantic.c	/^void VarDecAnalyze(TreeNode parent, int num) {$/;"	f
VarDecTrans	translateIR.c	/^void VarDecTrans(TreeNode parent, int num) {$/;"	f
VarList	name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon16
VarList	syntax.y	/^VarList : ParamDec COMMA VarList	$/;"	l
VarListAnalyze	semantic.c	/^void VarListAnalyze(TreeNode parent, int num) {$/;"	f
VarListTrans	translateIR.c	/^void VarListTrans(TreeNode parent, int num) {$/;"	f
WRITE_IR	IR.h	/^		ARG_IR, CALL_IR, PARAM_IR, READ_IR, WRITE_IR } InterCodeKind;$/;"	e	enum:__anon10
WriteIR	IR.c	/^InterCode WriteIR(Operand x) {$/;"	f
YFC	Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
ZERO	mips32.h	4;"	d
__ASM_H_	asm.h	2;"	d
__ERROR_H_	error.h	2;"	d
__FILE_H_	file.h	2;"	d
__IROPT_H_	IRopt.h	2;"	d
__IR_H_	IR.h	2;"	d
__MAIN_H_	main.h	2;"	d
__MIPS32_H_	mips32.h	2;"	d
__NAME_H_	name.h	2;"	d
__SEMANTICHELP_H_	semantichelp.h	2;"	d
__SEMANTIC_H_	semantic.h	2;"	d
__SYMTABLE_H_	symtable.h	2;"	d
__TRANSLATEIR_H_	translateIR.h	2;"	d
__TREE_H_	tree.h	2;"	d
addArrayElem	symtable.c	/^Type addArrayElem(Type array, Type elem) {$/;"	f
addAsmCode	asm.c	/^void addAsmCode(AsmCode code) {$/;"	f
addDecFunc	semantichelp.c	/^void addDecFunc(Symbol symbol) {$/;"	f
addFunc	semantichelp.c	/^void addFunc(struct FuncList **funcList, Symbol symbol) {$/;"	f
addIR	IR.c	/^void addIR(InterCode ir) {$/;"	f
allocTimes	symtable.h	/^	int allocTimes;$/;"	m	struct:HashTableInfo
argc	symtable.h	/^	int argc;$/;"	m	struct:Func
argsnum	semantic.c	/^int argsnum = 0;$/;"	v
argtype	symtable.h	/^	FieldList argtype;$/;"	m	struct:Func
array	symtable.h	/^		}array;$/;"	m	union:Type_::__anon2	typeref:struct:Type_::__anon2::__anon3
assignreduce	IRopt.c	/^InterCodes assignreduce(InterCodes IRhead) {$/;"	f
basic	symtable.h	/^		int basic;$/;"	m	union:Type_::__anon2
blockinteropt	IRopt.c	/^InterCodes blockinteropt(InterCodes IRhead) {$/;"	f
blocktempopt	IRopt.c	/^InterCodes blocktempopt(InterCodes blockhead) {$/;"	f
buffer	file.h	/^	char *buffer;$/;"	m	struct:Buffer
children	tree.h	/^	struct node *children[CHILD_NUM];$/;"	m	struct:node	typeref:struct:node::node
cleanHashTable	symtable.c	/^int cleanHashTable(void) {$/;"	f
cleanSymList	symtable.c	/^int cleanSymList(Symbol head) {$/;"	f
clearTree	tree.c	/^void clearTree(struct node *node)$/;"	f
closefile	file.c	/^closefile(void)$/;"	f
closeoutputfile	file.c	/^closeoutputfile(void)$/;"	f
cmpFieldList	semantichelp.c	/^int cmpFieldList(FieldList fieldList1, FieldList fieldList2) {$/;"	f
cmpFunc	semantichelp.c	/^int cmpFunc(struct Func *left, struct Func *right) {$/;"	f
cmpFuncSym	semantichelp.c	/^int cmpFuncSym(Symbol left, Symbol right) {$/;"	f
cmpFuncSymByName	semantichelp.c	/^int cmpFuncSymByName(Symbol left, Symbol right) {$/;"	f
cmpType	semantichelp.c	/^int cmpType(Type type1, Type type2) {$/;"	f
code	IR.h	/^	InterCode code;$/;"	m	struct:InterCodes_
code	asm.h	/^	AsmCode code;$/;"	m	struct:AsmCodes_
constantreduce	IRopt.c	/^InterCodes constantreduce(InterCodes IRhead) {$/;"	f
createSymNode	symtable.c	/^Symbol createSymNode(int type, char *name, ErrorInfo errorInfo) {$/;"	f
curFile	file.c	/^FILE *curFile = NULL;$/;"	v
curbuffer	file.c	/^struct Buffer *curbuffer = NULL;$/;"	v	typeref:struct:Buffer
curfilename	file.c	/^char *curfilename = NULL;$/;"	v
debug	main.c	/^int debug = 0;$/;"	v
debug2	main.c	/^int debug2 = 0;$/;"	v
debug3	main.c	/^int debug3 = 0;$/;"	v
deleteErrorInfoStack	error.c	/^void deleteErrorInfoStack(int type, int num) {$/;"	f
depth	tree.h	/^	int depth;$/;"	m	struct:node
downbound	symtable.h	/^			int downbound;$/;"	m	struct:Type_::__anon2::__anon3
dumpChar	file.c	/^char dumpChar(char c) {$/;"	f	file:
dumpString	file.c	/^char *dumpString(char *s) {$/;"	f	file:
elem	symtable.h	/^			Type elem;$/;"	m	struct:Type_::__anon2::__anon3
eof	file.h	/^	int eof;$/;"	m	struct:Buffer
errbuf	error.c	/^static char errbuf[100];$/;"	v	file:
errorInfo	error.h	/^	ErrorInfo errorInfo;$/;"	m	struct:ErrorInfoStack
errorInfo	symtable.h	/^			ErrorInfo errorInfo;$/;"	m	struct:Type_::__anon2::__anon4
errorInfo	symtable.h	/^	ErrorInfo errorInfo;$/;"	m	struct:FieldList_
errorInfo	symtable.h	/^	ErrorInfo errorInfo;$/;"	m	struct:SymNode
errorInfo	tree.h	/^	ErrorInfo errorInfo;$/;"	m	struct:node
errorcount	tree.h	/^	int errorcount;$/;"	m	struct:node
f	asm.h	/^	char *f;$/;"	m	struct:AsmCode_
false	main.h	9;"	d
falselist	IR.h	/^	Operandlist truelist, falselist, nextlist;$/;"	m	struct:IRinfo_
fieldList	tree.h	/^	FieldList fieldList;$/;"	m	struct:node
formatStr	IR.c	/^char *formatStr(InterCode ir, Operand op) {$/;"	f
freeDecFuncList	semantichelp.c	/^void freeDecFuncList() {$/;"	f
freeErrorInfoStack	error.c	/^void freeErrorInfoStack(struct ErrorInfoStack *head) {$/;"	f
freeFieldList	symtable.c	/^void freeFieldList(FieldList fieldList) {$/;"	f
freeFunc	symtable.c	/^void freeFunc(struct Func *func) {$/;"	f
freeIR	IR.c	/^void freeIR(InterCodes ir) {$/;"	f
freeSymNode	symtable.c	/^int freeSymNode(Symbol symNode) {$/;"	f
freeTimes	symtable.h	/^	int freeTimes;$/;"	m	struct:HashTableInfo
freeType	symtable.c	/^void freeType(Type type) {$/;"	f
freeVar	symtable.c	/^void freeVar(struct Var *var) {$/;"	f
free_buffer	file.c	/^free_buffer(struct Buffer *buffer){$/;"	f
func	symtable.h	/^		struct Func *func;$/;"	m	union:SymNode::__anon6	typeref:struct:SymNode::__anon6::Func
funcSymbol	semantichelp.h	/^	struct SymNode *funcSymbol;$/;"	m	struct:FuncList	typeref:struct:FuncList::SymNode
funcnum	IR.h	/^	int funcnum;$/;"	m	struct:InterCodes_
genArgsIR	translateIR.c	/^void genArgsIR(FieldList argtype, IRinfo irinfo) {$/;"	f
getDecFuncList	semantichelp.c	/^struct FuncList *getDecFuncList() {$/;"	f
getErrorEnd	error.c	/^extern int getErrorEnd() {$/;"	f
getErrorLine	error.c	/^extern int getErrorLine() {$/;"	f
getErrorStart	error.c	/^extern int getErrorStart() {$/;"	f
getFall	IR.c	/^Operandlist getFall() {$/;"	f
getHashTableInfo	symtable.c	/^void getHashTableInfo(void) {$/;"	f
getIRhead	IR.c	/^InterCodes getIRhead() {$/;"	f
getIRtail	IR.c	/^InterCodes getIRtail() {$/;"	f
getLabelnum	IR.c	/^int getLabelnum() {$/;"	f
getName	name.c	/^const char *getName(int type)$/;"	f
getNextLine	file.c	/^int getNextLine() {$/;"	f
getRegName	mips32.c	/^char *getRegName(int reg) {$/;"	f
getSymType	symtable.c	/^Type getSymType(Symbol symNode) {$/;"	f
getTempnum	IR.c	/^int getTempnum() {$/;"	f
getVarnum	IR.c	/^int getVarnum() {$/;"	f
getfalseRelop	name.c	/^char *getfalseRelop(const char *relop) {$/;"	f
hashTableInfo	symtable.c	/^struct HashTableInfo hashTableInfo;$/;"	v	typeref:struct:HashTableInfo
hash_pjw	symtable.c	/^unsigned int hash_pjw(char *name) {$/;"	f
ifreduce	IRopt.c	/^InterCodes ifreduce(InterCodes IRhead) {$/;"	f
indexNum	symtable.h	/^	int indexNum;$/;"	m	struct:HashTableInfo
initError	error.c	/^ErrorInfo initError(int type) {$/;"	f
init_buffer	file.c	/^init_buffer(){$/;"	f
initbasicblock	IRopt.c	/^InterCodes initbasicblock(InterCodes IRhead) {$/;"	f
initerrorBuffer	error.c	/^initerrorBuffer(char *errorbuffer) {$/;"	f
insert	symtable.c	/^int insert(Symbol symNode) {$/;"	f
irinfo	tree.h	/^	IRinfo irinfo;$/;"	m	struct:node
isAddr	IR.h	/^	int isAddr;$/;"	m	struct:Operand_
isAddr	symtable.c	/^int isAddr(Type type) {$/;"	f
isComputeAddr	IR.h	/^	int isComputeAddr;$/;"	m	struct:InterCode_
isDeclare	symtable.h	/^	int isDeclare;$/;"	m	struct:Func
isDeclare	symtable.h	/^	int isDeclare;$/;"	m	struct:Var
isDefine	symtable.h	/^	int isDefine;$/;"	m	struct:Func
isDefine	symtable.h	/^	int isDefine;$/;"	m	struct:Var
isFall	IR.c	/^int isFall(Operandlist fall) {$/;"	f
isParam	symtable.h	/^	int isParam;$/;"	m	struct:Var
isblockhead	IR.h	/^	int isblockhead;$/;"	m	struct:InterCodes_
k	asm.h	/^	int k;$/;"	m	struct:AsmCode_
kind	IR.h	/^	InterCodeKind kind;$/;"	m	struct:InterCode_
kind	IR.h	/^	OP_KIND kind;$/;"	m	struct:IRinfo_
kind	IR.h	/^	OP_KIND kind;$/;"	m	struct:Operand_
kind	asm.h	/^	AsmCodeKind kind;$/;"	m	struct:AsmCode_
kind	symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE} kind;$/;"	m	struct:Type_	typeref:enum:Type_::__anon1
lBuffer	file.h	/^	int lBuffer;$/;"	m	struct:Buffer
lMaxBuffer	file.c	/^int lMaxBuffer = 1000;$/;"	v
labelcount	IRopt.c	/^int labelcount[LABEL_NUM] = {0};$/;"	v
labelnum	IR.c	/^int labelnum = 0;$/;"	v
labelreduce	IRopt.c	/^InterCodes labelreduce(InterCodes IRhead) {$/;"	f
labelreduce2	IRopt.c	/^InterCodes labelreduce2(InterCodes IRhead) {$/;"	f
last	error.h	/^	struct ErrorInfoStack *last;$/;"	m	struct:ErrorInfoStack	typeref:struct:ErrorInfoStack::ErrorInfoStack
lineno	tree.h	/^	int lineno;$/;"	m	struct:node
lookup	symtable.c	/^Symbol lookup(char *name) {$/;"	f
lookupByType	symtable.c	/^Symbol lookupByType(char *name, int type) {$/;"	f
lookupFieldListElem	symtable.c	/^Type lookupFieldListElem(FieldList fieldList, char *name) {$/;"	f
lookupfieldListByName	semantichelp.c	/^FieldList lookupfieldListByName(FieldList fieldList, char *name) {$/;"	f
main	main.c	/^int main(int argc, char** argv)$/;"	f
mergeFieldList	symtable.c	/^FieldList mergeFieldList(FieldList front, FieldList tail) {$/;"	f
nBuffer	file.h	/^	int nBuffer;$/;"	m	struct:Buffer
nRow	file.h	/^	int nRow;$/;"	m	struct:Buffer
nTokenLength	file.h	/^	int nTokenLength;$/;"	m	struct:Buffer
nTokenNextStart	file.h	/^	int nTokenNextStart;$/;"	m	struct:Buffer
nTokenStart	file.h	/^	int nTokenStart;$/;"	m	struct:Buffer
name	name.c	/^const char *name[] = {$/;"	v
name	symtable.h	/^	char *name;$/;"	m	struct:FieldList_
name	symtable.h	/^	char *name;$/;"	m	struct:SymNode
newAsmCode	asm.c	/^AsmCode newAsmCode(AsmCodeKind kind) {$/;"	f
newAsmCodes	asm.c	/^AsmCodes newAsmCodes(AsmCode asmcode) {$/;"	f
newFieldList	symtable.c	/^FieldList newFieldList(char *name, Type type, FieldList tail, ErrorInfo errorInfo) {$/;"	f
newFunc	symtable.c	/^Symbol newFunc(char *name, Type Return, FieldList argtype, ErrorInfo errorInfo) {$/;"	f
newIRinfo	IR.c	/^IRinfo newIRinfo() {$/;"	f
newInterCode	IR.c	/^InterCode newInterCode() {$/;"	f
newInterCodes	IR.c	/^InterCodes newInterCodes(InterCode ir) {$/;"	f
newLabel	IR.c	/^Operand newLabel() {$/;"	f
newNode	tree.c	/^struct node *newNode(int type,int num, ...)$/;"	f
newOperand	IR.c	/^Operand newOperand(int kind) {$/;"	f
newStruct	symtable.c	/^Symbol newStruct(char *name, Type type, ErrorInfo errorInfo) {$/;"	f
newTemp	IR.c	/^Operand newTemp() {$/;"	f
newType	symtable.c	/^Type newType() {$/;"	f
newVar	symtable.c	/^Symbol newVar(char *name, Type type, ErrorInfo errorInfo) {$/;"	f
newfile	file.c	/^newfile(char *fn)$/;"	f
newoutputfile	file.c	/^newoutputfile(char *fn)$/;"	f
newtokenNode	tree.c	/^struct node *newtokenNode(int type)$/;"	f
next	IR.c	/^	struct Nlist_ *next;$/;"	m	struct:Nlist_	typeref:struct:Nlist_::Nlist_	file:
next	IR.h	/^	IRinfo next;$/;"	m	struct:IRinfo_
next	IR.h	/^	InterCodes prev, next;$/;"	m	struct:InterCodes_
next	IR.h	/^	Operandlist next;$/;"	m	struct:Operandlist_
next	asm.h	/^	AsmCodes prev, next;$/;"	m	struct:AsmCodes_
next	semantichelp.h	/^	struct FuncList *next;$/;"	m	struct:FuncList	typeref:struct:FuncList::FuncList
next	symtable.h	/^	Symbol next;$/;"	m	struct:SymNode
nextlist	IR.h	/^	Operandlist truelist, falselist, nextlist;$/;"	m	struct:IRinfo_
node	tree.h	/^struct node {$/;"	s
nodetype	tree.h	/^	int nodetype;$/;"	m	struct:node
nodevalue	tree.h	/^	union value nodevalue;$/;"	m	struct:node	typeref:union:node::value
num	error.h	/^	int num;$/;"	m	struct:ErrorInfoStack
num	symtable.h	/^	int num;	\/\/num of this hash node$/;"	m	struct:HashNode
num_float	IR.h	/^		float num_float;$/;"	m	union:Operand_::__anon9
num_int	IR.h	/^		int num_int;$/;"	m	union:Operand_::__anon9
op	IR.h	/^	Operand op;$/;"	m	struct:IRinfo_
op	IR.h	/^	Operand op;$/;"	m	struct:Operandlist_
op1	IR.h	/^			Operand op1;$/;"	m	struct:InterCode_::__anon11::__anon12
op1	IR.h	/^		}op1;$/;"	m	union:InterCode_::__anon11	typeref:struct:InterCode_::__anon11::__anon12
op2	IR.h	/^		}op2;$/;"	m	union:InterCode_::__anon11	typeref:struct:InterCode_::__anon11::__anon13
op3	IR.h	/^		}op3;$/;"	m	union:InterCode_::__anon11	typeref:struct:InterCode_::__anon11::__anon14
op4	IR.h	/^		}op4;$/;"	m	union:InterCode_::__anon11	typeref:struct:InterCode_::__anon11::__anon15
oplist	IR.c	/^	Operandlist oplist;$/;"	m	struct:Nlist_	file:
outputFile	file.c	/^FILE *outputFile = NULL;$/;"	v
outputfilename	file.c	/^char *outputfilename = NULL;$/;"	v
prev	IR.h	/^	InterCodes prev, next;$/;"	m	struct:InterCodes_
prev	asm.h	/^	AsmCodes prev, next;$/;"	m	struct:AsmCodes_
printfAllAsm	asm.c	/^void printfAllAsm(FILE *tag) {$/;"	f
printfAsm	asm.c	/^void printfAsm(FILE *tag, AsmCode asmcode) {$/;"	f
printfErrorRow	error.c	/^printfErrorRow(char *errmsg, int start, int end) {$/;"	f
printfExpIR	IR.c	/^void printfExpIR(FILE *tag, InterCode ir, int type) {$/;"	f
printfIR	IR.c	/^void printfIR(FILE *tag, InterCode ir) {$/;"	f
printfallAsmtoFile	file.c	/^printfallAsmtoFile() {$/;"	f
printfallIR	IR.c	/^void printfallIR(FILE *tag) {$/;"	f
printfallIRtoFile	file.c	/^printfallIRtoFile() {$/;"	f
pushErrorInfo	error.c	/^int pushErrorInfo(ErrorInfo errorInfo, int type) {$/;"	f
relop	IR.h	/^			Operand x, relop, y, z;$/;"	m	struct:InterCode_::__anon11::__anon15
result	IR.h	/^			Operand result, right1, right2;$/;"	m	struct:InterCode_::__anon11::__anon14
result	IR.h	/^			Operand result, right;$/;"	m	struct:InterCode_::__anon11::__anon13
right	IR.h	/^			Operand result, right;$/;"	m	struct:InterCode_::__anon11::__anon13
right1	IR.h	/^			Operand result, right1, right2;$/;"	m	struct:InterCode_::__anon11::__anon14
right2	IR.h	/^			Operand result, right1, right2;$/;"	m	struct:InterCode_::__anon11::__anon14
semanticAnalyze	semantic.c	/^void semanticAnalyze(TreeNode parent, int num) {$/;"	f
showAllSymbol	symtable.c	/^void showAllSymbol(void) {$/;"	f
showDecFuncList	semantichelp.c	/^void showDecFuncList() {$/;"	f
showFieldList	symtable.c	/^void showFieldList(FieldList fieldList) {$/;"	f
showFunc	symtable.c	/^void showFunc(struct Func *func) {$/;"	f
showOplist	IR.c	/^void showOplist(Operandlist oplist) {$/;"	f
showSymList	symtable.c	/^int showSymList(Symbol head) {$/;"	f
showSymbol	symtable.c	/^void showSymbol(Symbol symNode) {$/;"	f
showTree	tree.c	/^void showTree(struct node *node)$/;"	f
showType	symtable.c	/^void showType(Type type) {$/;"	f
showVar	symtable.c	/^void showVar(struct Var *var) {$/;"	f
size	symtable.h	/^			int size;$/;"	m	struct:Type_::__anon2::__anon3
specifierLock	semantic.c	/^int specifierLock = 0;$/;"	v
str	IR.h	/^		char *str;$/;"	m	union:Operand_::__anon9
str	tree.h	/^	char *str;$/;"	m	union:value
structdefnum	semantic.c	/^int structdefnum = 0;$/;"	v
structname	symtable.h	/^			char *structname;$/;"	m	struct:Type_::__anon2::__anon4
structure	symtable.h	/^			FieldList structure;$/;"	m	struct:Type_::__anon2::__anon4
structure	symtable.h	/^		Type structure;$/;"	m	union:SymNode::__anon6
symNode	symtable.h	/^	Symbol symNode;\/\/the head of list$/;"	m	struct:HashNode
symTable	symtable.c	/^struct HashNode symTable[HASHSIZE];$/;"	v	typeref:struct:HashNode
symbolNum	symtable.h	/^	int symbolNum;$/;"	m	struct:HashTableInfo
tail	symtable.h	/^	FieldList tail;$/;"	m	struct:FieldList_
tempnum	IR.c	/^int tempnum = 0;$/;"	v
tokenName	name.c	/^const char *tokenName[] = {$/;"	v
totalErrorInfo	error.c	/^static int totalErrorInfo = 0;$/;"	v	file:
transAllAsm	asm.c	/^void transAllAsm(InterCodes IRhead) {$/;"	f
transAsm	asm.c	/^void transAsm(InterCode ir) {$/;"	f
transadd	asm.c	/^void transadd(InterCode ir) {$/;"	f
transarg	asm.c	/^void transarg(InterCode ir) {$/;"	f
transassign	asm.c	/^void transassign(InterCode ir) {$/;"	f
transcall	asm.c	/^void transcall(InterCode ir) {$/;"	f
transdec	asm.c	/^void transdec(InterCode ir) {$/;"	f
transdiv	asm.c	/^void transdiv(InterCode ir) {$/;"	f
transfunc	asm.c	/^void transfunc(InterCode ir) {$/;"	f
transgoto	asm.c	/^void transgoto(InterCode ir) {$/;"	f
transif	asm.c	/^void transif(InterCode ir) {$/;"	f
translabel	asm.c	/^void translabel(InterCode ir) {$/;"	f
translateIR	translateIR.c	/^void translateIR(TreeNode parent, int num) {$/;"	f
transmul	asm.c	/^void transmul(InterCode ir) {$/;"	f
transparam	asm.c	/^void transparam(InterCode ir) {$/;"	f
transread	asm.c	/^void transread(InterCode ir) {$/;"	f
transreturn	asm.c	/^void transreturn(InterCode ir) {$/;"	f
transsub	asm.c	/^void transsub(InterCode ir) {$/;"	f
transwrite	asm.c	/^void transwrite(InterCode ir) {$/;"	f
true	main.h	8;"	d
truelist	IR.h	/^	Operandlist truelist, falselist, nextlist;$/;"	m	struct:IRinfo_
type	IR.h	/^	enum {String, Int, Float} type;$/;"	m	struct:Operand_	typeref:enum:Operand_::__anon8
type	symtable.h	/^	Type type;$/;"	m	struct:FieldList_
type	symtable.h	/^	Type type;$/;"	m	struct:Var
type	symtable.h	/^	int type;$/;"	m	struct:SymNode
type	tree.h	/^	Type type;$/;"	m	struct:node
upbound	symtable.h	/^			int upbound;$/;"	m	struct:Type_::__anon2::__anon3
updateChildDepth	tree.c	/^void updateChildDepth(struct node *node)$/;"	f
updatelabelcount	IRopt.c	/^InterCodes updatelabelcount(InterCodes IRhead) {$/;"	f
usedIndex	symtable.h	/^	int usedIndex[SYMBOLMAX];$/;"	m	struct:HashTableInfo
value	tree.h	/^union value {$/;"	u
var	symtable.h	/^		struct Var *var;$/;"	m	union:SymNode::__anon6	typeref:struct:SymNode::__anon6::Var
varnum	IR.c	/^int varnum = 0;$/;"	v
x	IR.h	/^			Operand x, relop, y, z;$/;"	m	struct:InterCode_::__anon11::__anon15
x	asm.h	/^	int x;$/;"	m	struct:AsmCode_
y	IR.h	/^			Operand x, relop, y, z;$/;"	m	struct:InterCode_::__anon11::__anon15
y	asm.h	/^	int y;$/;"	m	struct:AsmCode_
z	IR.h	/^			Operand x, relop, y, z;$/;"	m	struct:InterCode_::__anon11::__anon15
z	asm.h	/^	int z;$/;"	m	struct:AsmCode_
