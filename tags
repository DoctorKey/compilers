!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARRAY	Code/symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE, ERROR} kind;$/;"	e	enum:Type_::__anon1
Args	Code/name.h	/^	Exp, Args$/;"	e	enum:__anon7
Args	Code/syntax.y	/^Args : Exp COMMA Args	$/;"	l
ArgsAnalyze	Code/semantic.c	/^void ArgsAnalyze(struct node *parent, int num) {$/;"	f
BASIC	Code/symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE, ERROR} kind;$/;"	e	enum:Type_::__anon1
BISON	Code/Makefile	/^BISON = bison$/;"	m
BeginToken	Code/file.c	/^void BeginToken(char *t) {$/;"	f
Buffer	Code/file.h	/^struct Buffer {$/;"	s
CC	Code/Makefile	/^CC = gcc$/;"	m
CFILES	Code/Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Code/Makefile	/^CFLAGS =-g -std=c99$/;"	m
CHILD_NUM	Code/tree.h	7;"	d
CompSt	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon7
CompSt	Code/syntax.y	/^CompSt : LC DefList StmtList RC $/;"	l
CompStAnalyze	Code/semantic.c	/^void CompStAnalyze(struct node *parent, int num) {$/;"	f
Dec	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon7
Dec	Code/syntax.y	/^Dec : VarDec	$/;"	l
DecAnalyze	Code/semantic.c	/^void DecAnalyze(struct node *parent, int num) {$/;"	f
DecList	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon7
DecList	Code/syntax.y	/^DecList : Dec	$/;"	l
DecListAnalyze	Code/semantic.c	/^void DecListAnalyze(struct node *parent, int num) {$/;"	f
Def	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon7
Def	Code/syntax.y	/^Def : Specifier DecList SEMI $/;"	l
DefAnalyze	Code/semantic.c	/^void DefAnalyze(struct node *parent, int num) {$/;"	f
DefList	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon7
DefList	Code/syntax.y	/^DefList :	$/;"	l
DefListAnalyze	Code/semantic.c	/^void DefListAnalyze(struct node *parent, int num) {$/;"	f
DumpRow	Code/file.c	/^void DumpRow(void) {$/;"	f
ERROR	Code/symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE, ERROR} kind;$/;"	e	enum:Type_::__anon1
ErrorInfo	Code/error.h	/^struct ErrorInfo {$/;"	s
ErrorInfoStack	Code/error.h	/^struct ErrorInfoStack {$/;"	s
ErrorLine	Code/error.h	/^	int ErrorLine;$/;"	m	struct:ErrorInfo
ErrorLineStr	Code/error.h	/^	char *ErrorLineStr;$/;"	m	struct:ErrorInfo
Exp	Code/name.h	/^	Exp, Args$/;"	e	enum:__anon7
Exp	Code/syntax.y	/^Exp : Exp ASSIGNOP Exp $/;"	l
ExpAnalyze	Code/semantic.c	/^void ExpAnalyze(struct node *parent, int num) {$/;"	f
ExtDecList	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon7
ExtDecList	Code/syntax.y	/^ExtDecList : VarDec	$/;"	l
ExtDecListAnalyze	Code/semantic.c	/^void ExtDecListAnalyze(struct node *parent, int num) {$/;"	f
ExtDef	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon7
ExtDef	Code/syntax.y	/^ExtDef : Specifier ExtDecList SEMI $/;"	l
ExtDefAnalyze	Code/semantic.c	/^void ExtDefAnalyze(struct node *parent, int num) {$/;"	f
ExtDefList	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon7
ExtDefList	Code/syntax.y	/^ExtDefList : 	$/;"	l
ExtDefListAnalyze	Code/semantic.c	/^void ExtDefListAnalyze(struct node *parent, int num) {$/;"	f
FLEX	Code/Makefile	/^FLEX = flex$/;"	m
FLOAT	Code/tree.h	/^	float FLOAT;$/;"	m	union:value
FieldList	Code/symtable.h	/^typedef struct FieldList_* FieldList;$/;"	t	typeref:struct:FieldList_
FieldList_	Code/symtable.h	/^struct FieldList_ {$/;"	s
FreeErrorInfo	Code/error.c	/^void FreeErrorInfo(struct ErrorInfo *errorInfo) {$/;"	f
FunDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon7
FunDec	Code/syntax.y	/^FunDec : ID LP VarList RP $/;"	l
FunDecAnalyze	Code/semantic.c	/^void FunDecAnalyze(struct node *parent, int num) {$/;"	f
Func	Code/symtable.h	/^enum {Var, Func, NewType};$/;"	e	enum:__anon4
Func	Code/symtable.h	/^struct Func {$/;"	s
GFuncReturn	Code/semantic.c	/^Type GFuncReturn = NULL;$/;"	v
GerrorInfo	Code/error.c	/^struct ErrorInfo *GerrorInfo = NULL;$/;"	v	typeref:struct:ErrorInfo
GetErrorInfoByNum	Code/error.c	/^struct ErrorInfo *GetErrorInfoByNum(struct ErrorInfoStack *head, int num) {$/;"	f
GetNextChar	Code/file.c	/^int GetNextChar(char *b, int maxBuffer) {$/;"	f
GetTotalErrorInfo	Code/error.c	/^int GetTotalErrorInfo() {$/;"	f
Gspecifier	Code/semantic.c	/^Type Gspecifier = NULL;$/;"	v
HASHSIZE	Code/symtable.h	18;"	d
HashNode	Code/symtable.h	/^struct HashNode {$/;"	s
HashTableInfo	Code/symtable.h	/^struct HashTableInfo {$/;"	s
INT	Code/tree.h	/^	int INT;$/;"	m	union:value
IdErrorInfoStackHead	Code/error.c	/^struct ErrorInfoStack *IdErrorInfoStackHead = NULL;$/;"	v	typeref:struct:ErrorInfoStack
LAB_1	Code/main.h	8;"	d
LAB_2	Code/main.h	9;"	d
LFC	Code/Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Code/Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Code/Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
NewType	Code/symtable.h	/^enum {Var, Func, NewType};$/;"	e	enum:__anon4
NumErrorInfoStackHead	Code/error.c	/^struct ErrorInfoStack *NumErrorInfoStackHead = NULL;$/;"	v	typeref:struct:ErrorInfoStack
OBJS	Code/Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
OptTag	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon7
OptTag	Code/syntax.y	/^OptTag : 	$/;"	l
OptTagAnalyze	Code/semantic.c	/^void OptTagAnalyze(struct node *parent, int num) {$/;"	f
ParamDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon7
ParamDec	Code/syntax.y	/^ParamDec : Specifier VarDec	$/;"	l
ParamDecAnalyze	Code/semantic.c	/^void ParamDecAnalyze(struct node *parent, int num) {$/;"	f
PrintError	Code/error.c	/^void PrintError(char type, char *errorstring, ...) {$/;"	f
Program	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon7
Program	Code/syntax.y	/^Program : ExtDefList	$/;"	l
ProgramAnalyze	Code/semantic.c	/^void ProgramAnalyze(struct node *parent, int num) {$/;"	f
Return	Code/symtable.h	/^	Type Return;$/;"	m	struct:Func
STRUCTURE	Code/symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE, ERROR} kind;$/;"	e	enum:Type_::__anon1
SYMBOLMAX	Code/symtable.h	17;"	d
SemanticError	Code/error.c	/^void SemanticError(int type, struct ErrorInfo *errorInfo) {$/;"	f
ShowErrorInfo	Code/error.c	/^void ShowErrorInfo(struct ErrorInfo *errorInfo) {$/;"	f
ShowErrorInfoStack	Code/error.c	/^void ShowErrorInfoStack(struct ErrorInfoStack *head) {$/;"	f
Specifier	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon7
Specifier	Code/syntax.y	/^Specifier : TYPE $/;"	l
SpecifierAnalyze	Code/semantic.c	/^void SpecifierAnalyze(struct node *parent, int num) {$/;"	f
Stmt	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon7
Stmt	Code/syntax.y	/^Stmt : Exp SEMI	$/;"	l
StmtAnalyze	Code/semantic.c	/^void StmtAnalyze(struct node *parent, int num) {$/;"	f
StmtList	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon7
StmtList	Code/syntax.y	/^StmtList : 	$/;"	l
StmtListAnalyze	Code/semantic.c	/^void StmtListAnalyze(struct node *parent, int num) {$/;"	f
StructSpecifier	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon7
StructSpecifier	Code/syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC	$/;"	l
StructSpecifierAnalyze	Code/semantic.c	/^void StructSpecifierAnalyze(struct node *parent, int num) {$/;"	f
SymNode	Code/symtable.h	/^struct SymNode {$/;"	s
Tag	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon7
Tag	Code/syntax.y	/^Tag : ID	$/;"	l
TagAnalyze	Code/semantic.c	/^void TagAnalyze(struct node *parent, int num) {$/;"	f
Type	Code/symtable.h	/^typedef struct Type_* Type;$/;"	t	typeref:struct:Type_
Type_	Code/symtable.h	/^struct Type_ {$/;"	s
Var	Code/symtable.h	/^enum {Var, Func, NewType};$/;"	e	enum:__anon4
Var	Code/symtable.h	/^struct Var {$/;"	s
VarDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon7
VarDec	Code/syntax.y	/^VarDec : ID	$/;"	l
VarDecAnalyze	Code/semantic.c	/^void VarDecAnalyze(struct node *parent, int num) {$/;"	f
VarList	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon7
VarList	Code/syntax.y	/^VarList : ParamDec COMMA VarList	$/;"	l
VarListAnalyze	Code/semantic.c	/^void VarListAnalyze(struct node *parent, int num) {$/;"	f
YFC	Code/Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Code/Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Code/Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
__ERROR_H_	Code/error.h	2;"	d
__FILE_H_	Code/file.h	2;"	d
__MAIN_H_	Code/main.h	2;"	d
__NAME_H_	Code/name.h	2;"	d
__SEMANTIC_H_	Code/semantic.h	2;"	d
__SYMTABLE_H_	Code/symtable.h	2;"	d
__TREE_H_	Code/tree.h	2;"	d
allocTimes	Code/symtable.h	/^	int allocTimes;$/;"	m	struct:HashTableInfo
argc	Code/symtable.h	/^	int argc;$/;"	m	struct:Func
argsnum	Code/semantic.c	/^int argsnum = 0;$/;"	v
argtype	Code/symtable.h	/^	FieldList argtype;$/;"	m	struct:Func
array	Code/symtable.h	/^		}array;$/;"	m	union:Type_::__anon2	typeref:struct:Type_::__anon2::__anon3
basic	Code/symtable.h	/^		int basic;$/;"	m	union:Type_::__anon2
buffer	Code/file.h	/^	char *buffer;$/;"	m	struct:Buffer
children	Code/tree.h	/^	struct node *children[CHILD_NUM];$/;"	m	struct:node	typeref:struct:node::node
cleanHashTable	Code/symtable.c	/^int cleanHashTable(void) {$/;"	f
cleanSymList	Code/symtable.c	/^int cleanSymList(struct SymNode *head) {$/;"	f
clearTree	Code/tree.c	/^void clearTree(struct node *node)$/;"	f
closefile	Code/file.c	/^closefile(void)$/;"	f
cmpFieldList	Code/semantic.c	/^int cmpFieldList(FieldList fieldList1, FieldList fieldList2) {$/;"	f
cmpType	Code/semantic.c	/^int cmpType(Type type1, Type type2) {$/;"	f
createSymNode	Code/symtable.c	/^struct SymNode *createSymNode(int type, char *name, struct ErrorInfo *errorInfo) {$/;"	f
curFile	Code/file.c	/^FILE *curFile = NULL;$/;"	v
curbuffer	Code/file.c	/^struct Buffer *curbuffer = NULL;$/;"	v	typeref:struct:Buffer
curfilename	Code/file.c	/^char *curfilename = NULL;$/;"	v
debug	Code/main.c	/^int debug = 0;$/;"	v
debug2	Code/main.c	/^int debug2 = 0;$/;"	v
depth	Code/tree.h	/^	int depth;$/;"	m	struct:node
dumpChar	Code/file.c	/^char dumpChar(char c) {$/;"	f	file:
dumpString	Code/file.c	/^char *dumpString(char *s) {$/;"	f	file:
elem	Code/symtable.h	/^			Type elem;$/;"	m	struct:Type_::__anon2::__anon3
eof	Code/file.h	/^	int eof;$/;"	m	struct:Buffer
errbuf	Code/error.c	/^static char errbuf[100];$/;"	v	file:
errorInfo	Code/error.h	/^	struct ErrorInfo *errorInfo;$/;"	m	struct:ErrorInfoStack	typeref:struct:ErrorInfoStack::ErrorInfo
errorInfo	Code/symtable.h	/^	struct ErrorInfo *errorInfo;$/;"	m	struct:SymNode	typeref:struct:SymNode::ErrorInfo
errorInfo	Code/tree.h	/^	struct ErrorInfo *errorInfo;$/;"	m	struct:node	typeref:struct:node::ErrorInfo
false	Code/main.h	6;"	d
fieldList	Code/tree.h	/^	FieldList fieldList;$/;"	m	struct:node
floatValue	Code/symtable.h	/^		float floatValue;$/;"	m	union:Var::__anon5
freeErrorInfoStack	Code/error.c	/^void freeErrorInfoStack(struct ErrorInfoStack *head) {$/;"	f
freeFieldList	Code/symtable.c	/^void freeFieldList(FieldList fieldList) {$/;"	f
freeFunc	Code/symtable.c	/^void freeFunc(struct Func *func) {$/;"	f
freeSymNode	Code/symtable.c	/^int freeSymNode(struct SymNode *symNode) {$/;"	f
freeTimes	Code/symtable.h	/^	int freeTimes;$/;"	m	struct:HashTableInfo
freeType	Code/symtable.c	/^void freeType(Type type) {$/;"	f
freeVar	Code/symtable.c	/^void freeVar(struct Var *var) {$/;"	f
free_buffer	Code/file.c	/^free_buffer(struct Buffer *buffer){$/;"	f
func	Code/symtable.h	/^		struct Func *func;$/;"	m	union:SymNode::__anon6	typeref:struct:SymNode::__anon6::Func
getErrorEnd	Code/error.c	/^extern int getErrorEnd() {$/;"	f
getErrorLine	Code/error.c	/^extern int getErrorLine() {$/;"	f
getErrorStart	Code/error.c	/^extern int getErrorStart() {$/;"	f
getHashTableInfo	Code/symtable.c	/^void getHashTableInfo(void) {$/;"	f
getName	Code/name.c	/^const char *getName(int type)$/;"	f
getNextLine	Code/file.c	/^int getNextLine() {$/;"	f
getSymType	Code/symtable.c	/^Type getSymType(struct SymNode *symNode) {$/;"	f
hashTableInfo	Code/symtable.c	/^struct HashTableInfo hashTableInfo;$/;"	v	typeref:struct:HashTableInfo
hash_pjw	Code/symtable.c	/^unsigned int hash_pjw(char *name) {$/;"	f
indexNum	Code/symtable.h	/^	int indexNum;$/;"	m	struct:HashTableInfo
initError	Code/error.c	/^struct ErrorInfo *initError(int type) {$/;"	f
init_buffer	Code/file.c	/^init_buffer(){$/;"	f
initerrorBuffer	Code/error.c	/^initerrorBuffer(char *errorbuffer) {$/;"	f
insert	Code/symtable.c	/^int insert(struct SymNode *symNode) {$/;"	f
intValue	Code/symtable.h	/^		int intValue;$/;"	m	union:Var::__anon5
kind	Code/symtable.h	/^	enum {BASIC, ARRAY, STRUCTURE, ERROR} kind;$/;"	m	struct:Type_	typeref:enum:Type_::__anon1
lBuffer	Code/file.h	/^	int lBuffer;$/;"	m	struct:Buffer
lMaxBuffer	Code/file.c	/^int lMaxBuffer = 1000;$/;"	v
last	Code/error.h	/^	struct ErrorInfoStack *last;$/;"	m	struct:ErrorInfoStack	typeref:struct:ErrorInfoStack::ErrorInfoStack
lineno	Code/tree.h	/^	int lineno;$/;"	m	struct:node
lookup	Code/symtable.c	/^struct SymNode *lookup(char *name) {$/;"	f
lookupFieldListElem	Code/symtable.c	/^Type lookupFieldListElem(FieldList fieldList, char *name) {$/;"	f
main	Code/main.c	/^int main(int argc, char** argv)$/;"	f
main	Test/compare.c	/^int main(int argc, char** argv)$/;"	f
nBuffer	Code/file.h	/^	int nBuffer;$/;"	m	struct:Buffer
nRow	Code/file.h	/^	int nRow;$/;"	m	struct:Buffer
nTokenLength	Code/file.h	/^	int nTokenLength;$/;"	m	struct:Buffer
nTokenNextStart	Code/file.h	/^	int nTokenNextStart;$/;"	m	struct:Buffer
nTokenStart	Code/file.h	/^	int nTokenStart;$/;"	m	struct:Buffer
name	Code/name.c	/^const char *name[] = {$/;"	v
name	Code/symtable.h	/^	char *name;$/;"	m	struct:FieldList_
name	Code/symtable.h	/^	char *name;$/;"	m	struct:SymNode
newFieldList	Code/symtable.c	/^FieldList newFieldList(char *name, Type type, FieldList tail) {$/;"	f
newFunc	Code/symtable.c	/^struct SymNode *newFunc(char *name, Type Return, FieldList argtype, struct ErrorInfo *errorInfo) {$/;"	f
newNewType	Code/symtable.c	/^struct SymNode *newNewType(char *name, Type type, struct ErrorInfo *errorInfo) {$/;"	f
newNode	Code/tree.c	/^struct node *newNode(int type,int num, ...)$/;"	f
newType	Code/symtable.c	/^Type newType() {$/;"	f
newVar	Code/symtable.c	/^struct SymNode *newVar(char *name, Type type, struct ErrorInfo *errorInfo) {$/;"	f
newfile	Code/file.c	/^newfile(char *fn)$/;"	f
newtokenNode	Code/tree.c	/^struct node *newtokenNode(int type)$/;"	f
next	Code/symtable.h	/^	struct SymNode *next;$/;"	m	struct:SymNode	typeref:struct:SymNode::SymNode
node	Code/tree.h	/^struct node {$/;"	s
nodetype	Code/tree.h	/^	int nodetype;$/;"	m	struct:node
nodevalue	Code/tree.h	/^	union value nodevalue;$/;"	m	struct:node	typeref:union:node::value
num	Code/error.h	/^	int num;$/;"	m	struct:ErrorInfoStack
num	Code/symtable.h	/^	int num;	\/\/num of this hash node$/;"	m	struct:HashNode
printfErrorRow	Code/error.c	/^printfErrorRow(char *errmsg, int start, int end) {$/;"	f
pushErrorInfo	Code/error.c	/^int pushErrorInfo(struct ErrorInfo *errorInfo, int type) {$/;"	f
semanticAnalyze	Code/semantic.c	/^void semanticAnalyze(struct node *parent, int num) {$/;"	f
showAllSymbol	Code/symtable.c	/^void showAllSymbol(void) {$/;"	f
showFieldList	Code/symtable.c	/^void showFieldList(FieldList fieldList) {$/;"	f
showFunc	Code/symtable.c	/^void showFunc(struct Func *func) {$/;"	f
showSymList	Code/symtable.c	/^int showSymList(struct SymNode *head) {$/;"	f
showSymbol	Code/symtable.c	/^void showSymbol(struct SymNode *symNode) {$/;"	f
showTree	Code/tree.c	/^void showTree(struct node *node)$/;"	f
showType	Code/symtable.c	/^void showType(Type type) {$/;"	f
showVar	Code/symtable.c	/^void showVar(struct Var *var) {$/;"	f
size	Code/symtable.h	/^			int size;$/;"	m	struct:Type_::__anon2::__anon3
specifier	Code/symtable.h	/^		Type specifier;$/;"	m	union:SymNode::__anon6
str	Code/tree.h	/^	char *str;$/;"	m	union:value
structdefnum	Code/semantic.c	/^int structdefnum = 0;$/;"	v
structure	Code/symtable.h	/^		FieldList structure;$/;"	m	union:Type_::__anon2
symNode	Code/symtable.h	/^	struct SymNode *symNode;\/\/the head of list$/;"	m	struct:HashNode	typeref:struct:HashNode::SymNode
symTable	Code/symtable.c	/^struct HashNode symTable[HASHSIZE];$/;"	v	typeref:struct:HashNode
symbolNum	Code/symtable.h	/^	int symbolNum;$/;"	m	struct:HashTableInfo
tail	Code/symtable.h	/^	FieldList tail;$/;"	m	struct:FieldList_
test	Code/symtable.c	/^int test(void) {$/;"	f
tokenName	Code/name.c	/^const char *tokenName[] = {$/;"	v
totalErrorInfo	Code/error.c	/^static int totalErrorInfo = 0;$/;"	v	file:
true	Code/main.h	5;"	d
type	Code/symtable.h	/^	Type type;$/;"	m	struct:FieldList_
type	Code/symtable.h	/^	Type type;$/;"	m	struct:Var
type	Code/symtable.h	/^	int type;$/;"	m	struct:SymNode
type	Code/tree.h	/^	Type type;$/;"	m	struct:node
updateChildDepth	Code/tree.c	/^void updateChildDepth(struct node *node)$/;"	f
usedIndex	Code/symtable.h	/^	int usedIndex[SYMBOLMAX];$/;"	m	struct:HashTableInfo
value	Code/tree.h	/^union value {$/;"	u
var	Code/symtable.h	/^		struct Var *var;$/;"	m	union:SymNode::__anon6	typeref:struct:SymNode::__anon6::Var
varlistnum	Code/semantic.c	/^int varlistnum = 0;$/;"	v
