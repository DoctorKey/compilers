!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
Args	Code/name.h	/^	Exp, Args$/;"	e	enum:__anon1
Args	Code/syntax.y	/^Args : Exp COMMA Args	$/;"	l
BISON	Code/Makefile	/^BISON = bison$/;"	m
BeginToken	Code/file.c	/^void BeginToken(char *t) {$/;"	f
Buffer	Code/file.h	/^struct Buffer {$/;"	s
CC	Code/Makefile	/^CC = gcc$/;"	m
CFILES	Code/Makefile	/^CFILES = $(shell find .\/ -name "*.c")$/;"	m
CFLAGS	Code/Makefile	/^CFLAGS = -std=c99$/;"	m
CHILD_NUM	Code/tree.h	6;"	d
CompSt	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon1
CompSt	Code/syntax.y	/^CompSt : LC DefList StmtList RC $/;"	l
Dec	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon1
Dec	Code/syntax.y	/^Dec : VarDec	$/;"	l
DecList	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon1
DecList	Code/syntax.y	/^DecList : Dec	$/;"	l
Def	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon1
Def	Code/syntax.y	/^Def : Specifier DecList SEMI $/;"	l
DefList	Code/name.h	/^	DefList, Def, DecList, Dec,$/;"	e	enum:__anon1
DefList	Code/syntax.y	/^DefList :	$/;"	l
DumpRow	Code/file.c	/^void DumpRow(void) {$/;"	f
Exp	Code/name.h	/^	Exp, Args$/;"	e	enum:__anon1
Exp	Code/syntax.y	/^Exp : Exp ASSIGNOP Exp $/;"	l
ExtDecList	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon1
ExtDecList	Code/syntax.y	/^ExtDecList : VarDec	$/;"	l
ExtDef	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon1
ExtDef	Code/syntax.y	/^ExtDef : Specifier ExtDecList SEMI $/;"	l
ExtDefList	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon1
ExtDefList	Code/syntax.y	/^ExtDefList : 	$/;"	l
FLEX	Code/Makefile	/^FLEX = flex$/;"	m
FLOAT	Code/tree.h	/^	float FLOAT;$/;"	m	union:value
Filestack	Code/file.h	/^struct Filestack { $/;"	s
FunDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon1
FunDec	Code/syntax.y	/^FunDec : ID LP VarList RP $/;"	l
GetNextChar	Code/file.c	/^int GetNextChar(char *b, int maxBuffer) {$/;"	f
ID_index	Code/tree.h	/^	int ID_index;$/;"	m	union:value
INT	Code/tree.h	/^	int INT;$/;"	m	union:value
LFC	Code/Makefile	/^LFC = $(shell find .\/ -name "*.l" | sed s\/[^\/]*\\\\.l\/lex.yy.c\/)$/;"	m
LFILE	Code/Makefile	/^LFILE = $(shell find .\/ -name "*.l")$/;"	m
LFO	Code/Makefile	/^LFO = $(LFC:.c=.o)$/;"	m
OBJS	Code/Makefile	/^OBJS = $(CFILES:.c=.o)$/;"	m
OptTag	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon1
OptTag	Code/syntax.y	/^OptTag : 	$/;"	l
ParamDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon1
ParamDec	Code/syntax.y	/^ParamDec : Specifier VarDec	$/;"	l
PrintError	Code/error.c	/^void PrintError(char type, char *errorstring, ...) {$/;"	f
Program	Code/name.h	/^	Program, ExtDefList, ExtDef, ExtDecList,$/;"	e	enum:__anon1
Program	Code/syntax.y	/^Program : ExtDefList	$/;"	l
Specifier	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon1
Specifier	Code/syntax.y	/^Specifier : TYPE $/;"	l
Stmt	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon1
Stmt	Code/syntax.y	/^Stmt : Exp SEMI	$/;"	l
StmtList	Code/name.h	/^	CompSt, StmtList, Stmt, $/;"	e	enum:__anon1
StmtList	Code/syntax.y	/^StmtList : 	$/;"	l
StructSpecifier	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon1
StructSpecifier	Code/syntax.y	/^StructSpecifier : STRUCT OptTag LC DefList RC	$/;"	l
Tag	Code/name.h	/^	Specifier, StructSpecifier, OptTag, Tag,$/;"	e	enum:__anon1
Tag	Code/syntax.y	/^Tag : ID	$/;"	l
VarDec	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon1
VarDec	Code/syntax.y	/^VarDec : ID	$/;"	l
VarList	Code/name.h	/^	VarDec, FunDec, VarList, ParamDec,$/;"	e	enum:__anon1
VarList	Code/syntax.y	/^VarList : ParamDec COMMA VarList	$/;"	l
YFC	Code/Makefile	/^YFC = $(shell find .\/ -name "*.y" | sed s\/[^\/]*\\\\.y\/syntax.tab.c\/)$/;"	m
YFILE	Code/Makefile	/^YFILE = $(shell find .\/ -name "*.y")$/;"	m
YFO	Code/Makefile	/^YFO = $(YFC:.c=.o)$/;"	m
__ERROR_H_	Code/error.h	2;"	d
__FILE_H_	Code/file.h	2;"	d
__MAIN_H_	Code/main.h	2;"	d
__NAME_H_	Code/name.h	2;"	d
__TREE_H_	Code/tree.h	2;"	d
buffer	Code/file.h	/^	char *buffer;$/;"	m	struct:Buffer
buffer	Code/file.h	/^	struct Buffer *buffer;$/;"	m	struct:Filestack	typeref:struct:Filestack::Buffer
children	Code/tree.h	/^	struct node *children[CHILD_NUM];$/;"	m	struct:node	typeref:struct:node::node
cleanBuffer	Code/file.c	/^cleanBuffer(void) {$/;"	f
clearTree	Code/tree.c	/^void clearTree(struct node *node)$/;"	f
curbuffer	Code/file.c	/^struct Buffer *curbuffer = NULL;$/;"	v	typeref:struct:Buffer
curfile	Code/file.c	/^struct Filestack *curfile = NULL;$/;"	v	typeref:struct:Filestack
curfilename	Code/file.c	/^char *curfilename;$/;"	v
curpwd	Code/file.c	/^char *curpwd;$/;"	v
debug	Code/main.c	/^int debug = 0;$/;"	v
depth	Code/tree.h	/^	int depth;$/;"	m	struct:node
dumpChar	Code/file.c	/^char dumpChar(char c) {$/;"	f	file:
dumpString	Code/file.c	/^char *dumpString(char *s) {$/;"	f	file:
eof	Code/file.h	/^	int eof;$/;"	m	struct:Buffer
f	Code/file.h	/^	FILE *f;$/;"	m	struct:Filestack
false	Code/main.h	5;"	d
filename	Code/file.h	/^	char *filename;$/;"	m	struct:Filestack
free_buffer	Code/file.c	/^free_buffer(struct Buffer *buffer){$/;"	f
getCurFile	Code/file.c	/^FILE *getCurFile()$/;"	f
getName	Code/name.c	/^const char *getName(int type)$/;"	f
getNextLine	Code/file.c	/^int getNextLine() {$/;"	f
getpwd	Code/file.c	/^getpwd(char *dest, char *str)$/;"	f
init_buffer	Code/file.c	/^init_buffer(){$/;"	f
lBuffer	Code/file.h	/^	int lBuffer;$/;"	m	struct:Buffer
lMaxBuffer	Code/file.c	/^int lMaxBuffer = 1000;$/;"	v
lineno	Code/file.h	/^	int lineno;$/;"	m	struct:Filestack
lineno	Code/tree.h	/^	int lineno;$/;"	m	struct:node
main	Code/main.c	/^int main(int argc, char** argv)$/;"	f
main	Test/compare.c	/^int main(int argc, char** argv)$/;"	f
nBuffer	Code/file.h	/^	int nBuffer;$/;"	m	struct:Buffer
nRow	Code/file.h	/^	int nRow;$/;"	m	struct:Buffer
nTokenLength	Code/file.h	/^	int nTokenLength;$/;"	m	struct:Buffer
nTokenNextStart	Code/file.h	/^	int nTokenNextStart;$/;"	m	struct:Buffer
nTokenStart	Code/file.h	/^	int nTokenStart;$/;"	m	struct:Buffer
name	Code/name.c	/^const char *name[] = {$/;"	v
newNode	Code/tree.c	/^struct node *newNode(int type,int num, ...)$/;"	f
newfile	Code/file.c	/^newfile(char *fn)$/;"	f
newtokenNode	Code/tree.c	/^struct node *newtokenNode(int type)$/;"	f
node	Code/tree.h	/^struct node {$/;"	s
nodetype	Code/tree.h	/^	int nodetype;$/;"	m	struct:node
nodevalue	Code/tree.h	/^	union value nodevalue;$/;"	m	struct:node	typeref:union:node::value
popfile	Code/file.c	/^popfile(void)$/;"	f
prev	Code/file.h	/^	struct Filestack *prev;$/;"	m	struct:Filestack	typeref:struct:Filestack::Filestack
showTree	Code/tree.c	/^void showTree(struct node *node)$/;"	f
str	Code/tree.h	/^	char *str;$/;"	m	union:value
tokenName	Code/name.c	/^const char *tokenName[] = {$/;"	v
true	Code/main.h	4;"	d
updateChildDepth	Code/tree.c	/^void updateChildDepth(struct node *node)$/;"	f
value	Code/tree.h	/^union value {$/;"	u
